### 1、ES6 的新特性

1. let、const
2. 箭头函数、rest 不定参数、参数的默认值
3. 模板字符串
4. Promise
5. 解构赋值
6. 扩展运算符
7. 前端模块化（导入导出 export、import from）
8. 对象属性的简写
9. class
10. async await
11. Set、Map
12. Symbol
13. ...

### 2、数组的方法中，哪些会改变原数组，哪些不会？

会改变：push、unshift、pop、shift、splice、sort、reverse

不会改变：forEach、map、filter、every、some、reduce、find、includes、indexOf、concat、join、slice

### 3、== 和 === 的区别。

1. == 在进行比较时，会先隐式的将两个数据转换为同一类型，然后再进行值和类型的比较；
2. === 在进行时，直接进行值和类型的比较；

### 4、var、let、const 的区别

- 作用域：
  - var：函数作用域（通过函数来划分作用范围）
  - let、const：块级作用域（通过大括号来划分作用范围）
- 变量提升：
  - var：有变量提升
  - let、const：没有变量提升，但是有暂时性死区
- 修改值：
  - var、let：可以重新赋值；
  - const：不可以重新赋值（不能修改基本类型，以及不能修改引用类型的地址）
- 初始值：
  - var、let：可以不设置初始值；
  - const：必须设置初始值；
- 重复声明（同一作用域下）：
  - var：可以声明同名的变量；
  - let、const：不能声明同名的变量；

### 5、JS 数据类型

- 基本类型：数字、字符串、布尔值、null、undefined、Symbol、bigInt
- 引用类型：object

### 6、基本类型和引用类型的区别

- 存储位置
  - 基本类型：数据值保存在栈空间
  - 引用类型：数据值保存在堆空间，数据引用地址保存在栈空间
- 赋值方式
  - 基本类型：“值传递”，赋值完成后两个数据互相独立，其中一个修改不会影响另一个；
  - 引用类型：“址传递”，赋值完成后两个地址指向堆空间中的同一条数据，其中一个修改会影响另一个；
- 比较方式
  - 基本类型：“值比较”
  - 引用类型：“址比较”

### 7、改变 this 指向的方式有哪些？区别是什么？

- 参数区别
  - call、bind：第一个参数是 this 新的指向，剩余的参数逗号分隔依次传递；
  - **apply：第一个参数是 this 新的指向，剩余的参数需要以一个数组的形式传递；**
- 是否立即调用
  - call、apply：在改变 this 指向的同时，立即执行当前函数；
  - **bind：返回一个改变 this 指向的新函数，需要再次调用才会执行；**

```js
const obj = {}
const foo = (x, y) => {}
foo(1, 2);

foo.call(obj, 1, 2);
foo.apply(obj, [1, 2]);
foo.bind(obj, 1, 2)();
```

在实际项目开发中，大部分修改 this 指向的场景，都是将子作用域的 this 指向父级作用域，因此这种情况下可以直接用箭头函数来解决。

### 8、Promise 的方法有哪些？

1. `resolve()`：请求成功时，调用 `resolve()`，会将 Promise 对象的状态从“进行中”切换为“已成功”；
2. `reject()`：请求失败时，调用 `reject()`，会将 Promise 对象的状态从“进行中”切换为“已失败”；
3. `then()`：当 Promise 对象的状态从“进行中”切换为“已成功”时，触发 `then()`方法；
4. `catch()`：当 Promise 对象的状态从“进行中”切换为“已失败”时，触发 `catch()`方法；
5. `finally()`：当 Promise 对象的状态从“进行中”切换为“已成功”或“已失败”时，触发 `finally()` 方法；
6. `all()`：当数组中**所有请求都“已成功”**时，`all()` 的结果为“已成功”；只要有一个请求“已失败”，`all()` 的结果为“已失败”；
7. `race()`：数组中最先**完成**的请求的结果，会作为 `race()` 的结果；
8. `any()`：数组中最先**成功**的请求的结果，会作为 `any()` 的结果；

